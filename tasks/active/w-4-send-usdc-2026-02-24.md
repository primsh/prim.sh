# W-4: Implement send (USDC transfer on Base)

**Status:** Plan
**Spec:** `specs/wallet.md`
**Depends on:** W-2 (wallet creation — done), W-3 (balance queries — wave 2 peer)
**Blocks:** W-6 (funding request), W-7 (policy engine), W-8 (execution journal), W-9 (circuit breaker)

## Context

wallet.sh currently returns 501 for `POST /v1/wallets/:address/send`. W-4 implements the actual USDC transfer on Base. This is the highest-complexity task in wave 2: it involves key decryption, on-chain transaction signing, idempotency tracking, and balance verification.

## Goals

1. Send USDC on Base from a wallet.sh wallet to any address
2. Enforce ownership (caller must own the wallet)
3. Check balance before sending (reject if insufficient)
4. Track transactions with idempotency keys (replay-safe)
5. Return transaction hash and status

## Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Transfer method | Direct ERC-20 `transfer()` | Simple, standard. EIP-3009 gasless is for x402 payments, not arbitrary sends. Agent pays gas. |
| Signing | viem `walletClient.writeContract()` | Signs + broadcasts in one call. Uses decrypted private key from keystore. |
| Gas | Agent wallet pays ETH gas on Base | Base gas is sub-cent. Agent needs small ETH balance. |
| Idempotency | SQLite `executions` table | Key + canonical payload → deduplicate. Borrowed from Railgunner journal pattern. |
| Balance check | Call `getUsdcBalance()` from W-3 before sending | Fail fast with `insufficient_balance` error. |
| Tx status | Return `"pending"` immediately, don't wait for confirmation | Confirmation polling is caller's responsibility via GET /history (W-8). |

## Constants

- **USDC contract (Base):** `0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913`
- **USDC decimals:** 6
- **ERC-20 transfer ABI:** `transfer(address to, uint256 amount)` function signature

## Phase 1 — Execution journal (idempotency)

### Modify: `packages/wallet/src/db.ts`

Add `executions` table to the schema init:

```sql
CREATE TABLE IF NOT EXISTS executions (
  idempotency_key TEXT PRIMARY KEY,
  wallet_address  TEXT NOT NULL,
  action_type     TEXT NOT NULL,
  payload_hash    TEXT NOT NULL,
  status          TEXT NOT NULL,  -- "pending", "succeeded", "failed"
  result          TEXT,           -- JSON: { txHash, ... } or { error, ... }
  created_at      INTEGER NOT NULL,
  updated_at      INTEGER NOT NULL
)
```

Add index on `wallet_address` for history queries.

**New DB functions:**
- `getExecution(idempotencyKey: string): ExecutionRow | null`
- `insertExecution(params): void` — insert with status "pending"
- `completeExecution(idempotencyKey: string, status: "succeeded" | "failed", result: string): void`

**Idempotency logic (implemented in service, not DB):**

| key exists? | payload matches? | action |
|-------------|-----------------|--------|
| No | — | Insert new execution, proceed |
| Yes | Yes | Return stored result (200) |
| Yes | No | Return 409 `duplicate_request` |

**Payload hash:** SHA-256 of canonical JSON `{ to, amount }` (sorted keys). Use `node:crypto` `createHash("sha256")`.

## Phase 2 — Send service function

### Modify: `packages/wallet/src/service.ts`

**New function: `sendUsdc(address, request, caller)`**

Steps:
1. **Ownership check:** Call `checkOwnership(address, caller)`. Return 403/404 on failure.
2. **Idempotency check:** Call `getExecution(request.idempotencyKey)`.
   - If exists with same payload hash → return stored result
   - If exists with different payload hash → return 409
3. **Balance check:** Call `getUsdcBalance(address)` from W-3. Parse balance, compare to request amount. If insufficient → return 422 `insufficient_balance`.
4. **Decrypt key:** Call `decryptPrivateKey(row.encrypted_key)` from keystore.
5. **Insert pending execution:** Record in DB before attempting tx.
6. **Sign and send:** Create viem `WalletClient` with decrypted key, call `writeContract` with ERC-20 `transfer(to, amount)`.
7. **Record result:** On success → `completeExecution(key, "succeeded", { txHash })`. On failure → `completeExecution(key, "failed", { error })`.
8. **Return response:** `SendResponse` with txHash, status, etc.

**Return type:** `{ ok: true; data: SendResponse } | { ok: false; status: number; code: string; message: string }`

### Viem client setup

Create a `WalletClient` per-request (don't cache — each uses a different private key):
- `createWalletClient({ account: privateKeyToAccount(decryptedKey), chain: base, transport: http(RPC_URL) })`
- Call `walletClient.writeContract({ address: USDC_ADDRESS, abi: erc20TransferAbi, functionName: "transfer", args: [to, parseUnits(amount, 6)] })`
- Returns tx hash immediately (doesn't wait for confirmation)

### Amount conversion

- Request `amount` is human-readable: `"10.50"`
- Convert to raw: `parseUnits("10.50", 6)` → `10500000n`
- Validate: amount must be positive, must parse correctly

## Phase 3 — Wire route handler

### Modify: `packages/wallet/src/index.ts`

Replace the 501 stub at `POST /v1/wallets/:address/send` (line ~159):
- Parse request body as `SendRequest` (validate `to`, `amount`, `idempotencyKey` are present)
- Call `await sendUsdc(address, request, caller)`
- Return appropriate status code based on result

**Validation:**
- `to` must be a valid Ethereum address (check with viem's `isAddress()`)
- `amount` must be a positive decimal string
- `idempotencyKey` must be present and non-empty
- Missing fields → 400 `invalid_request`

## Phase 4 — Tests

### New file: `packages/wallet/test/send.test.ts`

**Mock strategy:**
- Mock the viem `writeContract` call (intercept the RPC request)
- Mock `getUsdcBalance` to return controlled values
- Use in-memory SQLite (`:memory:`) for execution journal

**Test cases:**

| Test | Setup | Expected |
|------|-------|----------|
| Successful send | Balance 100, send 10 | 200, txHash present, status "pending" |
| Insufficient balance | Balance 5, send 10 | 422, code "insufficient_balance" |
| Not owner | Caller ≠ wallet owner | 403, code "forbidden" |
| Wallet not found | Bad address | 404 |
| Idempotent replay (same payload) | Same key + same to/amount | 200, same txHash as original |
| Idempotent conflict (diff payload) | Same key + different amount | 409, code "duplicate_request" |
| Invalid address | `to: "not-an-address"` | 400, code "invalid_request" |
| Missing idempotency key | No key in request | 400, code "invalid_request" |
| RPC failure | writeContract throws | 502 or 500, execution marked "failed" |

## Files changed (summary)

| File | Action |
|------|--------|
| `packages/wallet/src/db.ts` | **Modify** — add executions table, getExecution/insertExecution/completeExecution |
| `packages/wallet/src/service.ts` | **Modify** — add sendUsdc function |
| `packages/wallet/src/index.ts` | **Modify** — replace send stub with real handler |
| `packages/wallet/test/send.test.ts` | **New** — send endpoint tests |

## Before closing

- [ ] `pnpm --filter @agentstack/wallet check` passes
- [ ] Successful send returns txHash and status "pending"
- [ ] Ownership enforced: caller must be wallet owner (403 otherwise)
- [ ] Balance checked before send (422 `insufficient_balance`)
- [ ] Idempotency: same key + same payload → cached result (200)
- [ ] Idempotency: same key + different payload → 409 `duplicate_request`
- [ ] Invalid inputs return 400 with specific error messages
- [ ] Execution journal records all attempts (pending → succeeded/failed)
- [ ] No new npm dependencies (viem already present)
