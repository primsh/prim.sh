# X4-2: Retry logic for facilitator settlement failures

## Context

X4-1 found that x402 facilitator settlement on Base Sepolia intermittently fails. The server-side `@x402/hono` middleware returns:

```
HTTP 402
{ "error": "Settlement failed", "details": "<facilitator error reason>" }
```

Currently `createPrimFetch` sends the signed retry and returns whatever comes back — if settlement fails, the agent gets a 402 and has to figure out what happened. These failures are transient (nonce collision, RPC timeout, gas estimation) and succeed on the next attempt.

## Goal

Add a single automatic retry with backoff inside `createPrimFetch` when the signed request comes back as a settlement failure. The agent should not need to implement retry logic per-call.

## Files to modify

| File | Change |
|------|--------|
| `packages/x402-client/src/client.ts` | Add settlement-failure detection + retry loop after line 182 |
| `packages/x402-client/src/types.ts` | Add optional `retrySettlement` config field |
| `packages/x402-client/test/client.test.ts` | Add 3-4 tests for retry behavior |

## Design

### Detection

After the signed retry (line 179-182 in `client.ts`), check if the response indicates settlement failure:

```
retryResponse.status === 402 AND body contains { error: "Settlement failed" }
```

Must clone the response before reading the body (can only read body once). If the body doesn't match, return the original response unchanged.

### Retry flow

```
Initial request → 402 → sign → retry with Payment-Signature
                                    ↓
                            retryResponse.status === 402?
                              ↓ yes                ↓ no
                        Clone + read body     Return response
                              ↓
                     body.error === "Settlement failed"?
                       ↓ yes                  ↓ no
                  Wait 2 seconds         Return original response
                       ↓                   (reconstruct from clone)
                 Re-sign payment
                 (fresh EIP-3009 auth)
                       ↓
                 Final retry
                       ↓
                 Return whatever comes back
```

### Key decisions

1. **Single retry only** — not a loop. One transient failure gets one retry. Two in a row means something is actually wrong.

2. **Re-sign, don't replay** — the EIP-3009 authorization has `validAfter`/`validBefore` timestamps and a deterministic nonce. After 2s backoff, the original might still be valid, but re-signing is safer (fresh timestamps). Call `httpClient.createPaymentPayload()` + `encodePaymentSignatureHeader()` again.

3. **Backoff: 2 seconds** — the facilitator batches settlements. 2s is enough for a retry to land in a different batch without being too slow for the agent.

4. **Body consumption** — `response.body` can only be read once. Use `response.clone()` before reading JSON. If it's not a settlement failure, reconstruct from the clone.

5. **Opt-out** — `retrySettlement: false` in config disables retry. Default: `true`.

### Decision table

| retryResponse.status | body.error | retrySettlement config | Action |
|---------------------|------------|----------------------|--------|
| 200-399 | n/a | any | Return immediately |
| 402 | "Settlement failed" | true (default) | Wait 2s → re-sign → final retry |
| 402 | "Settlement failed" | false | Return 402 as-is |
| 402 | anything else | any | Return 402 as-is |
| 403/500/etc | n/a | any | Return as-is |

### Config change

Add to `CreatePrimFetchConfig`:

```ts
/** Retry once on facilitator settlement failure. Default: true. */
retrySettlement?: boolean;
```

### Pseudocode (high-level)

After the existing retry (line 179-182):

```
if retryResponse.status !== 402 → return retryResponse

clone = retryResponse.clone()
try { body = await clone.json() } catch → return retryResponse
if body.error !== "Settlement failed" → return retryResponse
if config.retrySettlement === false → return retryResponse

await sleep(2000)

// Re-sign with fresh authorization
paymentPayload2 = await httpClient.createPaymentPayload(paymentRequired)
paymentHeaders2 = httpClient.encodePaymentSignatureHeader(paymentPayload2)
merge headers
finalResponse = await fetch(input, { ...init, headers: mergedHeaders })
return finalResponse
```

## Tests

| # | Scenario | Setup | Assert |
|---|----------|-------|--------|
| 1 | Settlement fails then succeeds | Mock: req1→402, req2→402 `{ error: "Settlement failed" }`, req3→200 | Returns 200, `fetch` called 3 times, ~2s delay between call 2 and 3 |
| 2 | Settlement fails twice | Mock: req1→402, req2→402 settlement, req3→402 settlement | Returns 402 (no second retry) |
| 3 | Non-settlement 402 is not retried | Mock: req1→402, req2→402 `{ error: "Insufficient funds" }` | Returns 402, `fetch` called exactly 2 times |
| 4 | retrySettlement: false | Mock: req1→402, req2→402 settlement | Returns 402, `fetch` called exactly 2 times |

Use `vi.useFakeTimers()` to avoid real 2s waits in tests.

## Before closing

- [ ] Run `pnpm -r test` (all package tests pass)
- [ ] Re-read each test assertion and verify both settlement-detected and non-settlement paths
- [ ] Verify `response.clone()` is called before `response.json()` — consuming body without clone is the #1 likely bug
- [ ] Verify the `paymentRequired` variable from the initial 402 parse is still in scope for re-signing (it's declared in the outer closure — should be fine)
- [ ] Verify `retrySettlement: false` actually skips the retry (both True and False paths tested)
