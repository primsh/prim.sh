# R-4: JMAP auth bridge + session bootstrap per mailbox

**Status:** pending
**Depends on:** R-3 (done)
**Blocks:** R-5 (read messages), R-6 (send messages)

## Context

R-3 built mailbox CRUD. R-5 and R-6 need to make JMAP calls (read/send email) on behalf of each mailbox. That requires two things: (1) credentials that JMAP accepts, and (2) per-mailbox JMAP session data (accountId, identityId, mailbox folder IDs).

### Key finding: Basic auth works against JMAP

Stalwart accepts `Authorization: Basic base64(email:password)` on its JMAP endpoint — confirmed in source code (`crates/http/src/auth/authenticate.rs`). No OAuth dance needed. relay.sh already generates a random password per mailbox and sends it to Stalwart. The only problem: R-3 stores a SHA-256 hash (one-way), so the password can't be recovered for JMAP calls.

### What R-4 actually needs to do

1. **Store the password encrypted** (recoverable) instead of hashed (one-way)
2. **Bootstrap JMAP session data** per mailbox after creation
3. **Expose a `getJmapContext()` function** that R-5/R-6 call to get everything they need

## Architecture

```
R-5/R-6 call getJmapContext(mailboxId)
  → db.ts: look up encrypted password + cached session data
  → jmap.ts: if session not cached, discover via GET /.well-known/jmap
  → return { apiUrl, accountId, identityId, inboxId, authHeader }
```

**Dependency direction:** `service.ts` → `jmap.ts` + `db.ts`. `jmap.ts` is a new thin client (like `stalwart.ts` for admin API, `jmap.ts` is for JMAP protocol). `index.ts` does not change — no new routes in R-4.

## Changes to Existing Code

### Password storage: hash → encrypted

**Current (R-3):** `password_hash TEXT` stores SHA-256 hash. One-way, can't recover password.

**New:** `password_enc TEXT` stores AES-256-GCM encrypted password. Recoverable with `RELAY_ENCRYPTION_KEY` env var.

The password is a random 64-char hex string generated by relay.sh, not a user secret. Encryption is defense-in-depth for the SQLite file — if someone has filesystem access they likely have the env vars too, but it's still better than plaintext.

#### Encryption scheme

Same pattern as wallet.sh keystore: AES-256-GCM with a 32-byte key.

- **Key:** `RELAY_ENCRYPTION_KEY` env var (64 hex chars = 32 bytes). Required.
- **Format stored in DB:** `iv:ciphertext:tag` (all hex-encoded)
- **IV:** 12 random bytes per encryption (never reused)

Functions in a new `src/crypto.ts`:
- `encryptPassword(plaintext: string): string` → returns `iv:ciphertext:tag`
- `decryptPassword(encrypted: string): string` → returns plaintext

### DB schema migration

Add new column, keep old column for backward compatibility during migration:

```sql
ALTER TABLE mailboxes ADD COLUMN password_enc TEXT;
ALTER TABLE mailboxes ADD COLUMN jmap_account_id TEXT;
ALTER TABLE mailboxes ADD COLUMN jmap_identity_id TEXT;
ALTER TABLE mailboxes ADD COLUMN jmap_inbox_id TEXT;
ALTER TABLE mailboxes ADD COLUMN jmap_drafts_id TEXT;
ALTER TABLE mailboxes ADD COLUMN jmap_sent_id TEXT;
ALTER TABLE mailboxes ADD COLUMN jmap_api_url TEXT;
```

Schema init in `getDb()` changes to include these columns. New mailboxes get `password_enc` populated; `password_hash` is still written for backward compat (existing queries don't break).

### service.ts changes

`createMailbox()`:
1. After Stalwart principal creation succeeds, call `bootstrapJmapSession()` to discover JMAP metadata
2. Store `password_enc` (encrypted) alongside `password_hash` (still hashed for compat)
3. Store JMAP session fields in DB

## New Files

### `src/crypto.ts` — Password encryption

```
encryptPassword(plaintext, key) → "iv:ciphertext:tag"
decryptPassword(encrypted, key) → plaintext
getEncryptionKey() → Buffer (from RELAY_ENCRYPTION_KEY env var)
```

### `src/jmap.ts` — JMAP session client

Thin HTTP client for JMAP protocol. Two responsibilities:

1. **Session discovery:** `GET /.well-known/jmap` with Basic auth → parse apiUrl, accountId
2. **Bootstrap calls:** `Mailbox/get` + `Identity/get` in a single JMAP batch → inbox/drafts/sent IDs + identityId

```
interface JmapSession {
  apiUrl: string;
  accountId: string;
  identityId: string;
  inboxId: string;
  draftsId: string;
  sentId: string;
}

async function discoverSession(jmapBaseUrl: string, authHeader: string): Promise<JmapSession>
```

`discoverSession` does three things in two HTTP calls:
1. `GET {jmapBaseUrl}/.well-known/jmap` → extracts `apiUrl` and `primaryAccounts["urn:ietf:params:jmap:mail"]` as `accountId`
2. `POST {apiUrl}` with a batched JMAP request:
   - `Mailbox/get` → find folders by `role`: `inbox`, `drafts`, `sent`
   - `Identity/get` → get the first identity's `id`

### `src/context.ts` — JMAP context provider

Exports one function that R-5/R-6 will call:

```
interface JmapContext {
  apiUrl: string;
  accountId: string;
  identityId: string;
  inboxId: string;
  draftsId: string;
  sentId: string;
  authHeader: string;  // "Basic base64(email:password)"
}

async function getJmapContext(mailboxId: string, callerWallet: string): Promise<ServiceResult<JmapContext>>
```

Logic:
1. Look up mailbox in DB, verify ownership
2. If JMAP session fields are cached in DB, decrypt password → build auth header → return context
3. If JMAP fields are null (shouldn't happen for new mailboxes, but handles migration), call `discoverSession()` and cache results

## Environment Variables

| Var | Default | Description |
|-----|---------|-------------|
| `RELAY_ENCRYPTION_KEY` | (required) | 64 hex chars (32 bytes) for AES-256-GCM |
| `STALWART_JMAP_URL` | `https://mail.relay.prim.sh` | Stalwart JMAP base URL (port 443) |

Note: `STALWART_API_URL` (port 8080, admin) and `STALWART_JMAP_URL` (port 443, JMAP) are different endpoints on the same server.

## Testing Strategy

### crypto.test.ts

| Scenario | Assert |
|----------|--------|
| Encrypt then decrypt roundtrip | `decrypt(encrypt(plaintext)) === plaintext` |
| Different IVs per call | Two encryptions of same plaintext produce different ciphertexts |
| Tampered ciphertext | Decrypt throws |
| Missing encryption key | Throws with clear error |

### jmap.test.ts (mocked fetch)

| Scenario | Assert |
|----------|--------|
| discoverSession parses session response | Returns correct apiUrl, accountId |
| discoverSession extracts mailbox roles | inboxId, draftsId, sentId from Mailbox/get response |
| discoverSession extracts identityId | First identity from Identity/get response |
| Stalwart returns error | Throws JmapError with mapped code |
| Missing inbox role | Returns error (inbox is required) |

### context.test.ts (mocked db + jmap)

| Scenario | Assert |
|----------|--------|
| Cached session data | Returns context without calling discoverSession |
| Missing session data | Calls discoverSession, caches result |
| Ownership check | Wrong wallet → not_found |
| Decrypt failure | Returns error, doesn't expose internals |

### Ownership truth table (unchanged from R-3)

```
mailbox_exists | wallet_matches | result
--------------|----------------|--------
false          | n/a            | not_found
true           | false          | not_found
true           | true           | success
```

## Files Summary

| File | Action | Purpose |
|------|--------|---------|
| `src/crypto.ts` | Create | AES-256-GCM encrypt/decrypt for passwords |
| `src/jmap.ts` | Create | JMAP session discovery + bootstrap |
| `src/context.ts` | Create | `getJmapContext()` — single entry point for R-5/R-6 |
| `src/db.ts` | Modify | Add JMAP columns to schema, add `password_enc` column, add update/query helpers |
| `src/service.ts` | Modify | Call `bootstrapJmapSession()` during `createMailbox()`, store encrypted password |
| `src/api.ts` | Modify | Add `JmapContext` type export |
| `test/crypto.test.ts` | Create | Encryption roundtrip tests |
| `test/jmap.test.ts` | Create | Session discovery tests (mocked fetch) |
| `test/context.test.ts` | Create | Context provider tests (mocked deps) |
| `test/service.test.ts` | Modify | Update createMailbox tests for new fields |

## Out of Scope

- **No new HTTP routes** — R-4 is internal plumbing, no API changes
- **Email/query, Email/get** → R-5
- **Email/set, EmailSubmission/set** → R-6
- **Token refresh / OAuth** — not needed, Basic auth is stateless

## Before Closing

- [ ] Run `pnpm -r check` from repo root (lint + typecheck + test pass)
- [ ] Verify `encryptPassword` → `decryptPassword` roundtrip works with random data
- [ ] Verify two encryptions of the same plaintext produce different ciphertexts (unique IV)
- [ ] Verify `getJmapContext()` returns `not_found` when `wallet_matches=false`
- [ ] Verify `discoverSession()` correctly maps Mailbox roles (`inbox`, `drafts`, `sent`) — not names
- [ ] Verify `RELAY_ENCRYPTION_KEY` missing → clear error at startup, not at first mailbox creation
