# W-5: Integrate x402 client (`@x402/fetch` wrapper)

**Status:** Plan
**Spec:** `specs/wallet.md`
**Depends on:** W-2 (wallet creation — done)
**Blocks:** W-6 (funding request may pay for notifications via x402)

## Context

wallet.sh agents need to pay for other x402-protected services (relay.sh, spawn.sh, etc.). W-5 builds a client-side wrapper that handles the 402 → sign → retry flow automatically. This is a library module, not a new API endpoint.

The `@x402/core` package (v2.4.0, already installed) provides `x402HTTPClient` for client-side protocol handling. The `@x402/evm` package provides EVM scheme signing (EIP-3009 `transferWithAuthorization`).

## Goals

1. Export `x402Fetch(url, options)` — drop-in fetch wrapper that auto-handles x402 402 responses
2. Use wallet.sh's encrypted keystore to sign payments (decrypt → sign → re-encrypt stays in memory only)
3. Handle the full flow: request → 402 → parse requirements → sign EIP-3009 → retry with Payment-Signature header
4. Expose as a reusable module other services can import

## Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Client SDK | `@x402/core/client` + `@x402/evm/exact/client` | First-party Coinbase packages, already in dependency tree |
| Signing scheme | EIP-3009 via `ExactEvmScheme` client | Gasless (facilitator pays gas), standard x402 flow |
| Key access | Decrypt from wallet.sh DB per-request | Keys never leave the process; decrypted key is in-memory only during signing |
| Retry behavior | Single automatic retry on 402 | One retry with payment. If second request also returns 402, return it to caller. |
| Module location | `packages/wallet/src/x402-client.ts` | Lives in wallet package since it needs keystore access |

## Architecture

```
Caller (agent or service)
    ↓
x402Fetch(url, { walletAddress, ...fetchOptions })
    ↓
1. fetch(url, options)                    → if 200, return
    ↓ (402)
2. Parse Payment-Required header          → extract payment requirements
    ↓
3. Load wallet from DB                    → get encrypted_key
4. Decrypt private key                    → in-memory only
5. Sign EIP-3009 transferWithAuthorization → via ExactEvmScheme client
    ↓
6. Encode Payment-Signature header
7. fetch(url, { ...options, headers: { "Payment-Signature": encoded } })
    ↓
8. Return response (200, 402, or other)
```

## Phase 1 — x402 client module

### New file: `packages/wallet/src/x402-client.ts`

**Setup:** Create an `x402Client` instance with EVM scheme registration:
- Import `x402Client` from `@x402/core/client`
- Import `ExactEvmScheme` from `@x402/evm/exact/client`
- Register scheme for network `"eip155:8453"` (Base)
- Wrap in `x402HTTPClient` for HTTP header handling

**Exported function signature:**

```
x402Fetch(url: string, options: X402FetchOptions): Promise<Response>
```

Where `X402FetchOptions` extends `RequestInit` with:
- `walletAddress: string` — which wallet.sh wallet to pay from
- `maxPayment?: string` — optional max USDC amount willing to pay (safety cap, default `"1.00"`)

**Flow:**
1. Make initial request with standard fetch
2. If response is not 402, return immediately
3. If 402: extract `Payment-Required` header via `decodePaymentRequiredHeader`
4. Look up wallet in DB via `getWalletByAddress(walletAddress)`
5. Verify wallet exists and is active (not deactivated)
6. Decrypt private key via `decryptPrivateKey(row.encrypted_key)`
7. Check price against `maxPayment` cap — reject if over limit
8. Create payment payload using x402 client (scheme handles EIP-3009 signing)
9. Encode as `Payment-Signature` header
10. Retry the request with the payment header attached
11. Return the retry response

**Error handling:**
- Wallet not found → throw (caller's problem — they passed a bad address)
- Wallet deactivated → throw
- Decryption failure → throw
- Price exceeds maxPayment → throw with descriptive message
- Second 402 → return the 402 response (don't loop)

**Key management:** The private key is decrypted into a `viem` account object, used for signing, then garbage collected. Never stored, never logged.

## Phase 2 — EVM scheme client setup

The `@x402/evm/exact/client` `ExactEvmScheme` needs a signer. In x402's architecture, the client scheme's `createPaymentPayload` method signs the EIP-3009 `transferWithAuthorization` message using EIP-712 typed data.

**Signer integration:** The scheme needs access to a viem account (from `privateKeyToAccount`). The x402 client scheme expects this to be provided per-request. Check the `ExactEvmScheme` constructor/method signatures to determine how to pass the signer — it likely accepts an `account` parameter or a signing callback.

**If the scheme expects a static signer:** Create a new `ExactEvmScheme` instance per-request with the decrypted account. This is fine for wallet.sh's scale.

**If the scheme accepts a dynamic signer:** Register once, pass the account when creating the payment payload.

The implementer should read the `@x402/evm/exact/client` source (`node_modules/@x402/evm/dist/`) to determine the exact API. The key thing: don't hold a reference to the decrypted private key beyond the signing call.

## Phase 3 — Tests

### New file: `packages/wallet/test/x402-client.test.ts`

**Mock strategy:**
- Mock global `fetch` to simulate 402 → 200 flow
- Mock the wallet DB with a test wallet (in-memory SQLite)
- Set `WALLET_MASTER_KEY` env for keystore decryption

**Test cases:**

| Test | Setup | Expected |
|------|-------|----------|
| Non-402 passthrough | fetch returns 200 | Returns 200 immediately, no signing |
| 402 → sign → 200 | First fetch 402, second fetch 200 | Returns 200, Payment-Signature header sent on retry |
| 402 → sign → still 402 | Both fetches return 402 | Returns second 402 (no infinite loop) |
| Wallet not found | Bad walletAddress | Throws error |
| Deactivated wallet | Wallet with deactivated_at set | Throws error |
| Price exceeds maxPayment | 402 price "$5.00", maxPayment "$1.00" | Throws with descriptive message |
| Payment-Signature header present | Verify retry request headers | `Payment-Signature` header is base64-encoded |

## Files changed (summary)

| File | Action |
|------|--------|
| `packages/wallet/src/x402-client.ts` | **New** — x402Fetch wrapper, EVM scheme setup |
| `packages/wallet/test/x402-client.test.ts` | **New** — client tests |
| `packages/wallet/src/index.ts` | **No change** — no new routes |
| `packages/wallet/package.json` | **Possibly modify** — may need `@x402/evm` as direct dependency if not already |

## Before closing

- [ ] `pnpm --filter @agentstack/wallet check` passes
- [ ] `x402Fetch` handles 402 → sign → retry flow correctly
- [ ] Non-402 responses pass through without signing
- [ ] Private key is decrypted only for signing, not stored
- [ ] maxPayment cap prevents overpaying
- [ ] No infinite retry loops (max one retry)
- [ ] Wallet not found / deactivated throws clear errors
- [ ] Payment-Signature header is correctly encoded
