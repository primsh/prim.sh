// Generated by gen:sdk — do not edit by hand
// Source: specs/openapi/faucet.yaml
// Regenerate: pnpm gen:sdk

// ── Types ──────────────────────────────────────────────────────────────────

export type EvmAddress = string;

export interface DripRequest {
  address: EvmAddress;
}

export interface DripResult {
  /** Transaction hash on Base Sepolia. May be "pending" if Circle API returns 204 */
  txHash: string;
  /** Human-readable amount dispensed (e.g. "10.00" for USDC, "0.01" for ETH) */
  amount: string;
  /** Token dispensed */
  currency: "USDC" | "ETH";
  /** CAIP-2 chain identifier for the network */
  chain: string;
  /** Which backend dispensed the USDC. Present only on USDC drip responses. */
  source?: "circle" | "treasury";
}

export interface StatusResponse {
  address: EvmAddress;
  usdc: FaucetAvailability;
  eth: FaucetAvailability;
}

export interface FaucetAvailability {
  /** Whether this faucet can be called right now for this address */
  available: boolean;
  /** Milliseconds until the rate limit window resets. 0 when available is true. */
  retryAfterMs: number;
}

export interface HealthResponse {
  /** Service name */
  service: string;
  /** Always "ok" when the service is running */
  status: "ok";
  /** CAIP-2 chain identifier for the configured network */
  network: string;
  /** Whether the service is configured for a testnet network */
  testnet: boolean;
}

export interface GetFaucetStatusParams {
  /** EVM wallet address (checksummed or lowercase) */
  address: EvmAddress;
}

// ── Client ─────────────────────────────────────────────────────────────────

export function createFaucetClient(primFetch: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>) {
  const baseUrl = "https://faucet.prim.sh";
  return {
    async dripUsdc(req: DripRequest): Promise<DripResult> {
      const url = `${baseUrl}/v1/faucet/usdc`;
      const res = await primFetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(req),
      });
      return res.json() as Promise<DripResult>;
    },
    async dripEth(req: DripRequest): Promise<DripResult> {
      const url = `${baseUrl}/v1/faucet/eth`;
      const res = await primFetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(req),
      });
      return res.json() as Promise<DripResult>;
    },
    async getFaucetStatus(params: GetFaucetStatusParams): Promise<StatusResponse> {
      const qs = new URLSearchParams();
      if (params.address !== undefined) qs.set("address", String(params.address));
      const query = qs.toString();
      const url = `${baseUrl}/v1/faucet/status${query ? `?${query}` : ""}`;
      const res = await primFetch(url);
      return res.json() as Promise<StatusResponse>;
    },
  };
}
