// Generated by gen:sdk — do not edit by hand
// Source: specs/openapi/mem.yaml
// Regenerate: pnpm gen:sdk

// ── Types ──────────────────────────────────────────────────────────────────

export interface CollectionResponse {
  /** Unique collection identifier (UUID). */
  id: string;
  /** Collection name (unique per wallet). */
  name: string;
  /** Ethereum address of the wallet that created this collection. */
  owner_wallet: string;
  /** Vector dimension for the collection's embedding model. */
  dimension: number;
  /** Distance metric used for similarity search. */
  distance: "Cosine" | "Euclid" | "Dot";
  /** Live Qdrant points count. null in list responses to avoid N+1 calls. */
  document_count: number | null;
  /** ISO 8601 timestamp of collection creation. */
  created_at: string;
}

export interface UpsertDocument {
  /** Document UUID. Auto-generated if omitted. */
  id?: string;
  /** Text content to embed and store. */
  text: string;
  /** Arbitrary key-value metadata stored alongside the vector. */
  metadata?: Record<string, unknown>;
}

export interface QueryMatch {
  /** Document ID (UUID). */
  id: string;
  /** Similarity score (higher = more similar). */
  score: number;
  /** Stored text content. */
  text: string;
  /** Stored metadata. */
  metadata: Record<string, unknown>;
}

export interface CacheGetResponse {
  /** Cache namespace. */
  namespace: string;
  /** Cache key. */
  key: string;
  /** Stored value (any JSON-serializable type). */
  value: unknown;
  /** ISO 8601 expiry timestamp, or null if the entry never expires. */
  expires_at: string | null;
}

export interface CreateCollectionRequest {
  /** Collection name. Must be unique per wallet. */
  name: string;
  /** Distance metric (default Cosine). */
  distance?: "Cosine" | "Euclid" | "Dot";
  /** Vector dimension (default 1536 for text-embedding-3-small). */
  dimension?: number;
}

export interface UpsertDocumentsRequest {
  /** Documents to embed and upsert. */
  documents: UpsertDocument[];
}

export interface QueryCollectionRequest {
  /** Query text to embed and search. */
  text: string;
  /** Maximum number of results to return (default 10). */
  top_k?: number;
  /** Qdrant-native filter passthrough for metadata filtering. */
  filter?: unknown;
}

export interface SetCacheRequest {
  /** Value to store (any JSON-serializable type). */
  value: unknown;
  /** TTL in seconds. Omit or null for permanent. */
  ttl?: number | null;
}

export interface ListCollectionsParams {
  /** Number of collections per page (1–100, default 20). */
  limit?: number;
  /** Page number (1-based, default 1). */
  page?: number;
}

export interface GetCollectionParams {
  /** Collection ID (UUID). */
  id: string;
}

export interface DeleteCollectionParams {
  /** Collection ID (UUID). */
  id: string;
}

export interface UpsertDocumentsParams {
  /** Collection ID (UUID). */
  id: string;
}

export interface QueryCollectionParams {
  /** Collection ID (UUID). */
  id: string;
}

export interface SetCacheParams {
  /** Cache namespace (scoped to wallet). */
  namespace: string;
  /** Cache key. */
  key: string;
}

export interface GetCacheParams {
  /** Cache namespace. */
  namespace: string;
  /** Cache key. */
  key: string;
}

export interface DeleteCacheParams {
  /** Cache namespace. */
  namespace: string;
  /** Cache key. */
  key: string;
}

export interface ListCollectionsResponse {
  collections: CollectionResponse[];
  meta: {
    page: number;
    per_page: number;
    total: number;
  };
}

export type DeleteCollectionResponse = Record<string, unknown>;

export interface UpsertDocumentsResponse {
  /** Number of documents upserted. */
  upserted: number;
  /** IDs of the upserted documents (in input order). */
  ids: string[];
}

export interface QueryCollectionResponse {
  matches: QueryMatch[];
}

export type DeleteCacheResponse = Record<string, unknown>;

// ── Client ─────────────────────────────────────────────────────────────────

export function createMemClient(primFetch: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>) {
  const baseUrl = "https://mem.prim.sh";
  return {
    async createCollection(req: CreateCollectionRequest): Promise<CollectionResponse> {
      const url = `${baseUrl}/v1/collections`;
      const res = await primFetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(req),
      });
      return res.json() as Promise<CollectionResponse>;
    },
    async listCollections(params: ListCollectionsParams): Promise<ListCollectionsResponse> {
      const qs = new URLSearchParams();
      if (params.limit !== undefined) qs.set("limit", String(params.limit));
      if (params.page !== undefined) qs.set("page", String(params.page));
      const query = qs.toString();
      const url = `${baseUrl}/v1/collections${query ? `?${query}` : ""}`;
      const res = await primFetch(url);
      return res.json() as Promise<ListCollectionsResponse>;
    },
    async getCollection(params: GetCollectionParams): Promise<CollectionResponse> {
      const url = `${baseUrl}/v1/collections/${encodeURIComponent(params.id)}`;
      const res = await primFetch(url);
      return res.json() as Promise<CollectionResponse>;
    },
    async deleteCollection(params: DeleteCollectionParams): Promise<DeleteCollectionResponse> {
      const url = `${baseUrl}/v1/collections/${encodeURIComponent(params.id)}`;
      const res = await primFetch(url, {
        method: "DELETE",
      });
      return res.json() as Promise<DeleteCollectionResponse>;
    },
    async upsertDocuments(params: UpsertDocumentsParams, req: UpsertDocumentsRequest): Promise<UpsertDocumentsResponse> {
      const url = `${baseUrl}/v1/collections/${encodeURIComponent(params.id)}/upsert`;
      const res = await primFetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(req),
      });
      return res.json() as Promise<UpsertDocumentsResponse>;
    },
    async queryCollection(params: QueryCollectionParams, req: QueryCollectionRequest): Promise<QueryCollectionResponse> {
      const url = `${baseUrl}/v1/collections/${encodeURIComponent(params.id)}/query`;
      const res = await primFetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(req),
      });
      return res.json() as Promise<QueryCollectionResponse>;
    },
    async setCache(params: SetCacheParams, req: SetCacheRequest): Promise<CacheGetResponse> {
      const url = `${baseUrl}/v1/cache/${encodeURIComponent(params.namespace)}/${encodeURIComponent(params.key)}`;
      const res = await primFetch(url, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(req),
      });
      return res.json() as Promise<CacheGetResponse>;
    },
    async getCache(params: GetCacheParams): Promise<CacheGetResponse> {
      const url = `${baseUrl}/v1/cache/${encodeURIComponent(params.namespace)}/${encodeURIComponent(params.key)}`;
      const res = await primFetch(url);
      return res.json() as Promise<CacheGetResponse>;
    },
    async deleteCache(params: DeleteCacheParams): Promise<DeleteCacheResponse> {
      const url = `${baseUrl}/v1/cache/${encodeURIComponent(params.namespace)}/${encodeURIComponent(params.key)}`;
      const res = await primFetch(url, {
        method: "DELETE",
      });
      return res.json() as Promise<DeleteCacheResponse>;
    },
  };
}
